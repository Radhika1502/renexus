import { Server } from 'http';
import WebSocket from 'ws';
import { v4 as uuidv4 } from 'uuid';
import { presenceManager, PresenceData } from './presence';

// Type aliases for clarity
type ClientId = string;
type RoomId = string;

// Extend PresenceData with additional fields
interface ExtendedPresenceData extends PresenceData {
  lastActive?: number;
  isTyping?: boolean;
  activeTaskId?: string;
}

// Type for WebSocket client connection
interface ClientConnection {
  ws: WebSocket;
  userId: string | null;
}

// Base WebSocket message type
interface WebSocketMessage {
  type: string;
  payload: any;
  metadata?: {
    timestamp?: number;
    userId?: string;
    clientId?: string;
    taskId?: string;
  };
}

// Message types
interface TaskUpdateMessage extends WebSocketMessage {
  type: 'TASK_UPDATE';
  payload: {
    taskId: string;
    type: 'STATUS_CHANGE' | 'DESCRIPTION_CHANGE' | 'ASSIGNEE_CHANGE' | 'TITLE_CHANGE' | 'DUE_DATE_CHANGE' | 'PRIORITY_CHANGE';
    changes: Record<string, unknown>;
    updatedAt: string;
  };
  metadata: {
    timestamp: number;
    userId: string;
    clientId: string;
  };
}

interface TypingIndicatorMessage extends WebSocketMessage {
  type: 'TYPING_INDICATOR';
  payload: {
    taskId: string;
    userId: string;
    isTyping: boolean;
  };
  metadata: {
    timestamp: number;
    userId: string;
    clientId: string;
  };
}

interface PresenceUpdateMessage extends WebSocketMessage {
  type: 'PRESENCE_UPDATE';
  payload: Partial<ExtendedPresenceData>;
  metadata: {
    timestamp: number;
    userId: string;
    clientId: string;
  };
}

interface CommentAddMessage extends WebSocketMessage {
  type: 'COMMENT_ADD';
  payload: {
    taskId: string;
    commentId: string;
    content: string;
    author: {
      id: string;
      name: string;
      avatarUrl?: string;
    };
    createdAt: string;
  };
  metadata: {
    timestamp: number;
    userId: string;
    clientId: string;
  };
}

interface AuthenticateMessage extends WebSocketMessage {
  type: 'AUTHENTICATE';
  payload: {
    userId: string;
  };
}

interface JoinRoomMessage extends WebSocketMessage {
  type: 'JOIN_ROOM';
  payload: {
    roomId: string;
  };
}

interface LeaveRoomMessage extends WebSocketMessage {
  type: 'LEAVE_ROOM';
  payload: {
    roomId: string;
  };
}

class WebSocketServer {
  private wss: WebSocket.Server;
  private clients: Map<ClientId, ClientConnection> = new Map();
  private clientUserMap: Map<ClientId, string> = new Map();
  private roomClients: Map<RoomId, Set<ClientId>> = new Map();
  private userRooms: Map<string, Set<RoomId>> = new Map();

  constructor(server: Server) {
    this.wss = new WebSocket.Server({ server });
    this.setupEventHandlers();
  }

  private setupEventHandlers() {
    this.wss.on('connection', (ws: WebSocket) => {
      const clientId = uuidv4();
      this.clients.set(clientId, {
        ws,
        userId: null
      });
      console.log(`New client connected: ${clientId}`);

      ws.on('message', (data: WebSocket.Data) => {
        try {
          const message: WebSocketMessage = JSON.parse(data.toString());
          this.handleMessage(clientId, message);
        } catch (error) {
          console.error('Error parsing message:', error);
        }
      });

      ws.on('close', () => {
        this.handleDisconnect(clientId);
      });
    });
  }

  private handleMessage(clientId: string, message: WebSocketMessage) {
    const { type, payload } = message;
    const client = this.clients.get(clientId);
    if (!client) return;

    // Update presence for this user
    if (client.userId) {
      const presenceUpdate: Partial<ExtendedPresenceData> = {
        status: 'online',
        activeTaskId: payload?.taskId,
        lastActive: Date.now()
      };
      presenceManager.updatePresence(client.userId, clientId, presenceUpdate);
    }

    // Handle specific message types
    switch (type) {
      case 'TASK_UPDATE': {
        const taskUpdate = message as TaskUpdateMessage;
        const roomId = payload.taskId;
        if (roomId && client.userId) {
          this.broadcastToRoom(roomId, {
            ...message,
            metadata: {
              ...message.metadata,
              timestamp: Date.now(),
              userId: client.userId,
              clientId,
            },
          }, clientId);
        }
        break;
      }
      case 'AUTHENTICATE': {
        const { userId } = payload;
        if (typeof userId === 'string') {
          client.userId = userId;
          this.clientUserMap.set(clientId, userId);
          
          // Add client to user's room
          const userRoom = this.userRooms.get(userId) || new Set();
          userRoom.add(clientId);
          this.userRooms.set(userId, userRoom);

          // Send welcome message
          this.notifyUser(userId, {
            type: 'WELCOME',
            payload: { userId },
            metadata: {
              timestamp: Date.now(),
              userId,
              clientId,
            },
          });
        }
        break;
      }
      case 'TYPING_INDICATOR': {
        const typingIndicator = message as TypingIndicatorMessage;
        const roomId = payload.taskId;
        if (roomId && client.userId) {
          // Update presence with typing status
          presenceManager.updatePresence(client.userId, clientId, {
            isTyping: payload.isTyping,
            activeTaskId: payload.taskId
          });
          
          this.broadcastToRoom(roomId, {
            ...message,
            metadata: {
              ...message.metadata,
              timestamp: Date.now(),
              userId: client.userId,
              clientId,
            },
          }, clientId);
        }
        break;
      }
      case 'PRESENCE_UPDATE': {
        const presenceUpdate = message as PresenceUpdateMessage;
        if (client.userId) {
          presenceManager.updatePresence(client.userId, clientId, presenceUpdate.payload);
          
          // Broadcast presence update to all rooms this user is in
          const userRoomIds = this.getUserRooms(clientId);
          
          userRoomIds.forEach(roomId => {
            this.broadcastToRoom(roomId, {
              type: 'PRESENCE_UPDATE',
              payload: presenceUpdate.payload,
              metadata: {
                timestamp: Date.now(),
                userId: client.userId!,
                clientId,
              },
            }, clientId);
          });
        }
        break;
      }
      case 'COMMENT_ADD': {
        const commentAdd = message as CommentAddMessage;
        const roomId = payload.taskId;
        if (roomId && client.userId) {
          this.broadcastToRoom(roomId, {
            ...message,
            metadata: {
              ...message.metadata,
              timestamp: Date.now(),
              userId: client.userId,
              clientId,
            },
          }, clientId);
        }
        break;
      }
      case 'JOIN_ROOM': {
        const { roomId } = payload;
        if (roomId && typeof roomId === 'string') {
          this.handleRoomJoin(clientId, roomId);
        }
        break;
      }
      case 'LEAVE_ROOM': {
        const { roomId } = payload;
        if (roomId && typeof roomId === 'string') {
          this.handleRoomLeave(clientId, roomId);
        }
        break;
      }
    }
  }

  private getUserRooms(clientId: string): RoomId[] {
    const result: RoomId[] = [];
    this.roomClients.forEach((clients, roomId) => {
      if (clients.has(clientId)) {
        result.push(roomId);
      }
    });
    return result;
  }

  private notifyUser(userId: string, message: WebSocketMessage) {
    const userClients = Array.from(this.clientUserMap.entries())
      .filter(([_, id]) => id === userId)
      .map(([clientId]) => clientId);
      
    userClients.forEach(clientId => {
      const client = this.clients.get(clientId);
      if (client?.ws.readyState === WebSocket.OPEN) {
        client.ws.send(JSON.stringify(message));
      }
    });
  }

  private broadcastToRoom(roomId: string, message: WebSocketMessage, excludeClientId?: ClientId) {
    // Broadcast to all clients in the room
    const clientsInRoom = this.roomClients.get(roomId) || new Set();
    const messageString = JSON.stringify(message);
    
    clientsInRoom.forEach(clientId => {
      if (clientId === excludeClientId) return;
      
      const client = this.clients.get(clientId);
      if (client?.ws.readyState === WebSocket.OPEN) {
        client.ws.send(messageString);
      }
    });
  }
  
  // Handle JOIN_ROOM and LEAVE_ROOM messages
  private handleRoomJoin(clientId: string, roomId: string) {
    const roomClients = this.roomClients.get(roomId) || new Set();
    roomClients.add(clientId);
    this.roomClients.set(roomId, roomClients);
    
    // Also track which rooms a user is in
    const client = this.clients.get(clientId);
    if (client?.userId) {
      const userRooms = this.userRooms.get(client.userId) || new Set();
      userRooms.add(roomId);
      this.userRooms.set(client.userId, userRooms);
    }
    
    console.log(`Client ${clientId} joined room ${roomId}`);
  }
  
  private handleRoomLeave(clientId: string, roomId: string) {
    const roomClients = this.roomClients.get(roomId);
    if (roomClients) {
      roomClients.delete(clientId);
      if (roomClients.size === 0) {
        this.roomClients.delete(roomId);
      } else {
        this.roomClients.set(roomId, roomClients);
      }
    }
    
    // Also remove from user's rooms
    const client = this.clients.get(clientId);
    if (client?.userId) {
      const userRooms = this.userRooms.get(client.userId);
      if (userRooms) {
        userRooms.delete(roomId);
        if (userRooms.size === 0) {
          this.userRooms.delete(client.userId);
        } else {
          this.userRooms.set(client.userId, userRooms);
        }
      }
    }
    
    console.log(`Client ${clientId} left room ${roomId}`);
  }
  
  private handleDisconnect(clientId: string) {
    const client = this.clients.get(clientId);
    if (!client) return;

    // Update presence
    if (client.userId) {
      presenceManager.updatePresence(client.userId, clientId, { status: 'offline' });
      
      // Remove from all rooms
      const userRooms = this.getUserRooms(clientId);
      userRooms.forEach(roomId => this.handleRoomLeave(clientId, roomId));
      
      // Notify other clients about disconnect
      userRooms.forEach(roomId => {
        this.broadcastToRoom(roomId, {
          type: 'PRESENCE_UPDATE',
          payload: { status: 'offline' },
          metadata: {
            timestamp: Date.now(),
            userId: client.userId!,
            clientId,
          }
        }, clientId);
      });
      
      // Remove from user map
      this.clientUserMap.delete(clientId);
    }
    
    // Remove client
    this.clients.delete(clientId);
    console.log(`Client disconnected: ${clientId}`);
  }
}

export default WebSocketServer;
